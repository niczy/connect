module.exports = Socket

var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var once = require('once')

var RECONNECT_TIMEOUT = 5000

inherits(Socket, EventEmitter)

function Socket (url, opts) {
  if (!(this instanceof Socket)) return new Socket(url, opts)
  EventEmitter.call(this)
  if (!opts) opts = {}

  this._url = url
  this._reconnect = (opts.reconnect !== undefined)
    ? opts.reconnect
    : RECONNECT_TIMEOUT
  this._init()
}

Socket.prototype.send = function (message) {
  if (this._ws && this._ws.readyState === WebSocket.OPEN) {
    if (typeof message === 'object')
      message = JSON.stringify(message)
    this._ws.send(message)
  }
}

Socket.prototype.destroy = function (onclose) {
  if (onclose) this.once('close', onclose)
  try {
    this._ws.close()
  } catch (err) {
    this._onclose()
  }
}

Socket.prototype._init = function () {
  this._errored = false
  this._ws = new WebSocket(this._url)
  this._ws.onopen = this._onopen.bind(this)
  this._ws.onmessage = this._onmessage.bind(this)
  this._ws.onclose = this._onclose.bind(this)
  this._ws.onerror = once(this._onerror.bind(this))
}

Socket.prototype._onopen = function () {
  this.emit('ready')
}

Socket.prototype._onerror = function (err) {
  this._errored = true

  // On error, close socket...
  this.destroy()

  // ...and try to reconnect after a timeout
  if (this._reconnect) {
    this._timeout = setTimeout(this._init.bind(this), this._reconnect)
    this.emit('warning', err)
  } else {
    this.emit('error', err)
  }
}


Socket.prototype._onmessage = function (event) {
  var message = event.data
  try {
    message = JSON.parse(event.data)
  } catch (err) {}
  this.emit('message', message)
}

Socket.prototype._onclose = function () {
  clearTimeout(this._timeout)
  if (this._ws) {
    this._ws.onopen = null
    this._ws.onerror = null
    this._ws.onmessage = null
    this._ws.onclose = null
  }
  this._ws = null
  if (!this._errored) this.emit('close')
}
