var BitField = require('bitfield')
var bncode = require('bncode')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')
var Rusha = require('rusha-browserify') // Fast SHA1 (works in browser)

var PIECE_LENGTH = 16 * 1024

var sharedMetadata = {}
var sharedBitfield = {}

function sha1 (buf) {
  return (new Rusha()).digestFromBuffer(buf)
}

module.exports = function (metadata, opts) {

  if (!Buffer.isBuffer(metadata) && typeof metadata === 'object') {
    opts = metadata
    metadata = undefined
  }

  opts = opts || {}
  var shared = opts.shared

  inherits(ut_metadata, EventEmitter)

  function ut_metadata (wire) {
    EventEmitter.call(this)

    this._wire = wire

    this._metadataComplete = false
    this._metadataSize = null
    this._remainingRejects = null // how many reject messages to tolerate before quitting
    this._fetching = false

    if (Buffer.isBuffer(metadata)) {
      this._gotMetadata(metadata)
    }
  }

  ut_metadata.prototype.onHandshake = function (infoHash, peerId, extensions) {
    this._infoHash = infoHash.toString('hex')
  }

  ut_metadata.prototype.onExtendedHandshake = function (handshake) {
    if (!handshake.m.ut_metadata) {
      return this.emit('warning', new Error('Peer does not support ut_metadata'))
    }
    if (!handshake.metadata_size) {
      return this.emit('warning', new Error('Peer does not have metadata'))
    }

    this._metadataSize = handshake.metadata_size
    this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH)
    this._remainingRejects = this._numPieces * 2

    if (this._fetching) {
      this._requestPieces()
    }
  }

  ut_metadata.prototype.onMessage = function (buf) {
    var dict, trailer
    try {
      var str = buf.toString()
      var trailerIndex = str.indexOf('ee') + 2
      dict = bncode.decode(str.substring(0, trailerIndex))
      trailer = buf.slice(trailerIndex)
    } catch (err) {
      // drop invalid messages
      return
    }

    switch (dict.msg_type) {
      case 0:
        // ut_metadata request (from peer)
        // example: { 'msg_type': 0, 'piece': 0 }
        this._onRequest(dict.piece)
        break
      case 1:
        // ut_metadata data (in response to our request)
        // example: { 'msg_type': 1, 'piece': 0, 'total_size': 3425 }
        this._onData(dict.piece, trailer, dict.total_size)
        break
      case 2:
        // ut_metadata reject (peer doesn't have piece we requested)
        // { 'msg_type': 2, 'piece': 0 }
        this._onReject(dict.piece)
        break
    }
  }

  // Expose high-level, friendly API (fetch/cancel)
  ut_metadata.prototype.fetch = function () {
    if (this._metadataComplete) {
      return
    }
    this._fetching = true
    if (this._metadataSize) {
      this._requestPieces()
    }
  }

  ut_metadata.prototype.cancel = function () {
    this._fetching = false
  }

  ut_metadata.prototype._send = function (dict, trailer) {
    var buf = bncode.encode(dict)
    if (Buffer.isBuffer(trailer)) {
      buf = Buffer.concat([buf, trailer])
    }
    this._wire.extended('ut_metadata', buf)
  }

  ut_metadata.prototype._request = function (piece) {
    this._send({ msg_type: 0, piece: piece })
  }

  ut_metadata.prototype._data = function (piece, buf, totalSize) {
    var msg = { msg_type: 1, piece: piece }
    if (typeof totalSize === 'number') {
      msg.total_size = totalSize
    }
    this._send(msg, buf)
  }

  ut_metadata.prototype._reject = function (piece) {
    this._send({ msg_type: 2, piece: piece })
  }

  ut_metadata.prototype._onRequest = function (piece) {
    if (piece < 0 || piece >= this._numPieces) {
      return this.emit('warning', new Error('got request for invalid piece number'))
    }
    if (this._metadataComplete) {
      var start = piece * PIECE_LENGTH
      var end = start + PIECE_LENGTH
      if (end > this._metadataSize) {
        end = this._metadataSize
      }
      var buf = this.metadata.slice(start, end)
      this._data(piece, buf, this._metadataSize)
    }
  }

  ut_metadata.prototype._onData = function (piece, buf, totalSize) {
    if (buf.length > PIECE_LENGTH) {
      return
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    if (shared) {
      sharedMetadata[this._infoHash].copy(this.metadata, piece * PIECE_LENGTH)
    }
    buf.copy(this.metadata, piece * PIECE_LENGTH)
    this._bitfield.set(piece)

    this._checkDone()
  }

  ut_metadata.prototype._onReject = function (piece) {
    if (this._remainingRejects > 0 && this._fetching) {
      // If we haven't been rejected too much, then try to request the piece again
      this._request(piece)
      this._remainingRejects -= 1
    } else {
      this.emit('warning', new Error('Peer sent "reject" too much'))
    }
  }

  ut_metadata.prototype._requestPieces = function () {
    this._bitfield = new BitField(this._numPieces)
    this.metadata = new Buffer(this._metadataSize)

    if (shared && !sharedMetadata[this._infoHash]) {
      sharedMetadata[this._infoHash] = new Buffer(this._metadataSize)
      sharedBitfield[this._infoHash] = new BitField(this._numPieces)
    }

    for (var piece = 0; piece < this._numPieces; piece++) {
      this._request(piece)
    }
  }

  ut_metadata.prototype._checkDone = function () {
    var numPieces = this._numPieces
    var infoHash = this._infoHash

    if (this._metadataComplete) {
      return
    }

    function check (metadata, bitfield) {
      var done = true
      for (var piece = 0; piece < numPieces; piece++) {
        if (!bitfield.get(piece)) {
          done = false
          break
        }
      }
      if (!done) return

      // check hash
      var info
      try {
        info = bncode.encode(bncode.decode(metadata).info)
      } catch (err) {
        // if buffer fails to decode, then data was corrupt
        return false
      }
      return sha1(info) === infoHash
    }

    console.dir(sharedMetadata)

    if (shared) {
      if (check(sharedMetadata[this._infoHash], sharedBitfield[this._infoHash])) {
        this._gotMetadata(sharedMetadata[this._infoHash])
      } else {
        sharedBitfield[this._infoHash] = new BitField(this._numPieces)
      }
    }

    if (check(this.metadata, this._bitfield)) {
      this._gotMetadata(this.metadata)
    } else {
      this._failedMetadata()
    }

  }

  ut_metadata.prototype._gotMetadata = function (_metadata) {
    this.cancel()
    this.metadata = _metadata
    this._metadataComplete = true
    this._metadataSize = this.metadata.length
    this._wire.extendedHandshake.metadata_size = this._metadataSize
    this.emit('metadata', this.metadata)
  }

  ut_metadata.prototype._failedMetadata = function () {
    this._bitfield = new BitField(0) // reset bitfield & try again
    this._remainingRejects -= this._numPieces
    if (this._remainingRejects > 0) {
      this._requestPieces()
    } else {
      this.emit('warning', new Error('Peer sent invalid metadata'))
    }
  }

  return ut_metadata
}
