/*global FileList */

module.exports = createTorrent

module.exports.announceList = [
  [ 'udp://tracker.publicbt.com:80' ],
  [ 'udp://tracker.openbittorrent.com:80' ],
  [ 'udp://open.demonii.com:1337' ],
  [ 'udp://tracker.webtorrent.io:80' ],
  [ 'wss://tracker.webtorrent.io' ] // For WebRTC peers (see: WebTorrent.io)
]

module.exports.parseInput = parseInput

var bencode = require('bencode')
var BlockStream = require('block-stream')
var calcPieceLength = require('piece-length')
var corePath = require('path')
var FileReadStream = require('filestream/read')
var flatten = require('flatten')
var fs = require('fs')
var MultiStream = require('multistream')
var once = require('once')
var parallel = require('run-parallel')
var sha1 = require('simple-sha1')
var stream = require('stream')
var Transform = stream.Transform

/**
 * Create a torrent.
 * @param  {string|File|FileList|Buffer|Stream|Array.<string|File|Buffer|Stream>} input
 * @param  {Object} opts
 * @param  {string=} opts.name
 * @param  {Date=} opts.creationDate
 * @param  {string=} opts.comment
 * @param  {string=} opts.createdBy
 * @param  {boolean|number=} opts.private
 * @param  {number=} opts.pieceLength
 * @param  {Array.<Array.<string>>=} opts.announceList
 * @param  {Array.<string>=} opts.urlList
 * @param  {function} cb
 * @return {Buffer} buffer of .torrent file data
 */
function createTorrent (input, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }
  if (!opts) opts = {}
  parseInput(input, opts, function (err, files) {
    if (err) return cb(err)
    onFiles(files, opts, cb)
  })
}

function parseInput (input, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }
  if (!opts) opts = {}

  if (isFileList(input))
    input = Array.prototype.slice.call(input)
  if (!Array.isArray(input))
    input = [ input ]

  if (input.length === 0) throw new Error('invalid input type')

  if (!opts.name)
    opts.name = input[0].name || (typeof input[0] === 'string' && corePath.basename(input))
  if (opts.name === undefined)
    throw new Error('missing option \'name\' and unable to infer it from input[0].name')

  // If there's just one file, allow the name to be set by `opts.name`
  if (input.length === 1 && !input[0].name) input[0].name = opts.name

  var numPaths = input.reduce(function (sum, item) {
    return sum + Number(typeof item === 'string')
  }, 0)

  parallel(input.map(function (item) {
    return function (cb) {
      var file = {}

      if (isBlob(item)) {
        file.getStream = getBlobStream(item)
        file.length = item.size
      } else if (Buffer.isBuffer(item)) {
        file.getStream = getBufferStream(item)
        file.length = item.length
      } else if (isReadable(item)) {
        if (!opts.pieceLength)
          throw new Error('must specify `pieceLength` option if input is Stream')
        file.getStream = getStreamStream(item, file)
        file.length = 0
      } else if (typeof item === 'string') {
        var keepRoot = numPaths > 1
        getFiles(item, keepRoot, cb)
        return // early return!
      } else {
        throw new Error('invalid input type in array')
      }
      if (!item.name) throw new Error('missing requied `name` property on input')
      file.path = item.name.split(corePath.sep)
      cb(null, file)
    }
  }), function (err, files) {
    if (err) return cb(err)
    files = flatten(files)

    if (numPaths === 0) process.nextTick(function () {
      cb(null, files) // dezalgo
    })
    else cb(null, files)
  })
}

function getFiles (path, keepRoot, cb) {
  traversePath(getFileInfo, path, function (err, files) {
      if (err) return cb(err)

      if (Array.isArray(files)) files = flatten(files)
      else files = [ files ]

      var dirName = corePath.normalize(path)
      if (keepRoot || files.length === 1) {
        dirName = dirName.slice(0, dirName.lastIndexOf(corePath.sep) + 1)
      } else {
        if (dirName[dirName.length - 1] !== corePath.sep) dirName += corePath.sep
      }

      files.forEach(function (file) {
        file.getStream = getFilePathStream(file.path)
        file.path = file.path.replace(dirName, '').split(corePath.sep)
      })

      cb(null, files)
    })
}

function getFileInfo (path, cb) {
  cb = once(cb)
  fs.stat(path, function (err, stat) {
    if (err) return cb(err)
    var info = {
      length: stat.size,
      path: path
    }
    cb(null, info)
  })
}

function traversePath (fn, path, cb) {
  fs.readdir(path, function (err, entries) {
    if (err && err.code === 'ENOTDIR') {
      // this is a file
      fn(path, cb)
    } else if (err) {
      // real error
      cb(err)
    } else {
      // this is a folder
      parallel(entries.map(function (entry) {
        return function (cb) {
          traversePath(fn, corePath.join(path, entry), cb)
        }
      }), cb)
    }
  })
}

function getPieceList (files, pieceLength, cb) {
  cb = once(cb)
  var pieces = []
  var length = 0

  var streams = files.map(function (file) {
    return file.getStream
  })

  var remainingHashes = 0
  var pieceNum = 0
  var ended = false

  new MultiStream(streams)
    .pipe(new BlockStream(pieceLength, { nopad: true }))
    .on('data', function (chunk) {
      length += chunk.length

      var i = pieceNum
      sha1(chunk, function (hash) {
        pieces[i] = hash
        remainingHashes -= 1
        maybeDone()
      })
      remainingHashes += 1
      pieceNum += 1
    })
    .on('end', function () {
      ended = true
      maybeDone()
    })
    .on('error', cb)

  function maybeDone () {
    if (ended && remainingHashes === 0)
      cb(null, new Buffer(pieces.join(''), 'hex'), length)
  }
}

function onFiles (files, opts, cb) {
  var announceList = opts.announceList !== undefined
    ? opts.announceList
    : opts.announce !== undefined
      ? opts.announce.map(function (u) { return [ u ] })
      : module.exports.announceList // default

  var torrent = {
    info: {
      name: opts.name
    },
    announce: announceList[0][0],
    'announce-list': announceList,
    'creation date': Number(opts.creationDate) || Date.now(),
    encoding: 'UTF-8'
  }

  if (opts.comment !== undefined)
    torrent.info.comment = opts.comment

  if (opts.createdBy !== undefined)
    torrent.info['created by'] = opts.createdBy

  if (opts.private !== undefined)
    torrent.info.private = Number(opts.private)

  // "ssl-cert" key is for SSL torrents, see:
  //   - http://blog.libtorrent.org/2012/01/bittorrent-over-ssl/
  //   - http://www.libtorrent.org/manual-ref.html#ssl-torrents
  //   - http://www.libtorrent.org/reference-Create_Torrents.html
  if (opts.sslCert !== undefined)
    torrent.info['ssl-cert'] = opts.sslCert

  if (opts.urlList !== undefined)
    torrent['url-list'] = opts.urlList

  var singleFile = files.length === 1

  var pieceLength = opts.pieceLength || calcPieceLength(files.reduce(sumLength, 0))
  torrent.info['piece length'] = pieceLength

  getPieceList(files, pieceLength, function (err, pieces, torrentLength) {
    if (err) return cb(err)
    torrent.info.pieces = pieces

    files.forEach(function (file) {
      delete file.getStream
    })

    if (!singleFile) {
      torrent.info.files = files
    } else {
      torrent.info.length = torrentLength
    }

    cb(null, bencode.encode(torrent))
  })
}

/**
 * Accumulator to sum file lengths
 * @param  {number} sum
 * @param  {Object} file
 * @return {number}
 */
function sumLength (sum, file) {
  return sum + file.length
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob (obj) {
  return typeof Blob !== 'undefined' && obj instanceof Blob
}

/**
 * Check if `obj` is a W3C `FileList` object
 * @param  {*} obj
 * @return {boolean}
 */
function isFileList (obj) {
  return typeof FileList === 'function' && obj instanceof FileList
}

/**
 * Check if `obj` is a node Readable stream
 * @param  {*} obj
 * @return {boolean}
 */
function isReadable (obj) {
  return typeof obj === 'object' && typeof obj.pipe === 'function'
}

/**
 * Convert a `File` to a lazy readable stream.
 * @param  {File|Blob} file
 * @return {function}
 */
function getBlobStream (file) {
  return function () {
    return new FileReadStream(file)
  }
}

/**
 * Convert a `Buffer` to a lazy readable stream.
 * @param  {Buffer} buffer
 * @return {function}
 */
function getBufferStream (buffer) {
  return function () {
    var s = new stream.PassThrough()
    s.end(buffer)
    return s
  }
}

/**
 * Convert a file path to a lazy readable stream.
 * @param  {string} path
 * @return {function}
 */
function getFilePathStream (path) {
  return function () {
    return fs.createReadStream(path)
  }
}

/**
 * Convert a readable stream to a lazy readable stream. Adds instrumentation to track
 * the number of bytes in the stream and set `file.length`.
 *
 * @param  {Stream} stream
 * @param  {Object} file
 * @return {function}
 */
function getStreamStream (stream, file) {
  return function () {
    var counter = new Transform()
    counter._transform = function (buf, enc, done) {
      file.length += buf.length
      this.push(buf)
      done()
    }
    stream.pipe(counter)
    return counter
  }
}
